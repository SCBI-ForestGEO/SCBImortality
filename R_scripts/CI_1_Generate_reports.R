# Generate reports looking at latest mortality census raw data ####
## this script is run automatically when there is a push 

# clear environment ####
rm(list = ls())

# load libraries ####
library(here)
library(readxl)

# load latest mortality data ####

## get the name of latest excel form
# latest_FFFs <- list.files(here("raw_data/FFF_excel/"), pattern = ".xlsx", full.names = T)
# latest_FFFs <- latest_FFFs[which.max(as.numeric(regmatches(latest_FFFs, regexpr("20\\d\\d", latest_FFFs))))] # take the latest file only
latest_FFFs <- "raw_data/FFF_excel/SCBI Mortality 2022.xlsx" #update this for cencus 2023
static_FFFs <- "raw_data/FFF_excel/SCBI Mortality static 2022.xlsx" #this is static form that was used for one week during 2022 that is missing one column 
fieldFixes_FFF <- "raw_data/FFF_excel/SCBI Mortality field fixes 2022.xlsx" #this is a form that was filled after the quadrat with remaining issues were re-dispatched in Decemver 2022


## load the latest mortality survey

mort1 <- as.data.frame(read_xlsx(latest_FFFs, sheet = "section_1", .name_repair = "minimal" ))
mort2 <- as.data.frame(read_xlsx(latest_FFFs, sheet = "section_2", .name_repair = "minimal" ))

mort <- merge(mort1, mort2, by = intersect(names(mort1), names(mort2)))

mort_root <- as.data.frame(read_xlsx(latest_FFFs, sheet = "Root", .name_repair = "minimal" ))
mort <- cbind(SurveyorID = mort_root$Personnel[match(mort$`Submission Id`, mort_root$`Submission Id`)],
              date = mort_root$"Date/Time"[match(mort$`Submission Id`, mort_root$`Submission Id`)],
              mort)

static1 <- as.data.frame(read_xlsx(static_FFFs, sheet = "section_1", .name_repair = "minimal" ))
static2 <- as.data.frame(read_xlsx(static_FFFs, sheet = "section_2", .name_repair = "minimal" ))

static <- merge(static1, static2, by = intersect(names(static1), names(static2)))

static_root <- as.data.frame(read_xlsx(static_FFFs, sheet = "Root", .name_repair = "minimal" ))
static <- cbind(SurveyorID = static_root$Personnel[match(static$`Submission Id`, static_root$`Submission Id`)],
              date = static_root$"Date/Time"[match(static$`Submission Id`, static_root$`Submission Id`)],
              static)

fldfix1 <- as.data.frame(read_xlsx(fieldFixes_FFF, sheet = "section_1", .name_repair = "minimal" ))
fldfix2 <- as.data.frame(read_xlsx(fieldFixes_FFF, sheet = "section_2", .name_repair = "minimal" ))

fldfix <- merge(fldfix1, fldfix2, by = intersect(names(fldfix1), names(fldfix2)))

fldfix_root <- as.data.frame(read_xlsx(fieldFixes_FFF, sheet = "Root", .name_repair = "minimal" ))
fldfix <- cbind(SurveyorID = "Katherina",
                date = static_root$"Date/Time"[match(fldfix$`Submission Id`, fldfix_root$`Submission Id`)],
                fldfix)
fldfix$Quad <- ifelse(nchar(fldfix$Quad) == 3, paste0("0", fldfix$Quad), fldfix$Quad)





#confirm difference between mort, static  and fldfix
setdiff(names(mort), names(static))
setdiff(names(static), names(mort))

setdiff(names(mort), names(fldfix))
setdiff(names(fldfix), names(mort))

static$"Crown position < 10 cm DBH" <- NA

mort$"Data Correction" <- NA
static$"Data Correction" <- NA

#confirm mort and static are same now 
setdiff(names(mort), names(static))
setdiff(names(static), names(mort))

setdiff(names(mort), names(fldfix))
setdiff(names(fldfix), names(mort))

### figure out previous and current status columns
status_column <- rev(grep("Status", names(mort), value = T))[1]
previous_status_column <- rev(grep("Status", names(mort), value = T))[2]

# stack and remove duplicated records in the data frames
mort <- rbind(data.frame(what = "mort", mort, check.names = F), data.frame(what = "static", static, check.names = F), data.frame(what = "fldfix", fldfix, check.names = F))

mort <- mort[!duplicated(mort), ]

# compare data -> if anything is duplicated remove the row with fewer info but leave both if there is a conflict

mort_dupST <- paste(mort$Tag, mort$StemTag)[duplicated(paste(mort$Tag, mort$StemTag))]

for(st in mort_dupST) {
  
  x <- mort[paste(mort$Tag, mort$StemTag) %in% st, ]
  
  # cases where one or more of the rows are NA and one or more other have info
   idx_col_to_impute <- which(!colSums(is.na(x)) %in% c(0, nrow(x))) 
   
    if(length(idx_col_to_impute)>0) {
      for(j in idx_col_to_impute) {
        
        
        idx_to_copy <- ifelse(all(x[!is.na(x[,j]),j] == x[!is.na(x[,j]),j][1]), 1, 0) # if all non-Na are the same give 1, else 0
        
        if(names(x)[j] %in% "FAD" & idx_to_copy == 0) idx_to_copy  <- which.max(nchar(x[!is.na(x[,j]),j])) # if we are looking at FAD, take the most comprehensive value
        
        if(names(x)[j] %in% "Dead DBH" & idx_to_copy == 0 & all(grepl("D", x[, status_column])) & all(grepl("A", x[, previous_status_column]))) idx_to_copy  <- which(!is.na(x[, j]) & x[, j] >0) # if we are looking at a newly dead tree and j in 'DBH Dead',  take the one with dbh measured
        
        if(idx_to_copy > 0) {
          
          x[,j] <- x[!is.na(x[,j]),j][idx_to_copy] 
          
        } else { 
          stop ("duplicated tag issue: not all non-NA are equal in ", st)}
      }
    }
   
   
  # now reduce by removing duplicated rows
   x <- x[!duplicated(x[,-c(1:4, ncol(x))]), ]
   
   # if still more than one row
  if(nrow(x) == 2) {
    
   
    can_reduce <- identical(all(x[1,-c(1:4, ncol(x))] == x[2,-c(1:4, ncol(x))]), TRUE) # if any FALSE --> we know we won't be combining rows, unless one of them is from field fix
    
    if(!can_reduce & any(x$what %in% "fldfix")) {
      cat(x$Tag[1], ": keeping", names(x[,-c(1:4, ncol(x))])[which(x[1,-c(1:4, ncol(x))] != x[2,-c(1:4, ncol(x))])], "from field fix data where error was", x$"Data Correction"[x$what %in% "fldfix"], "\n")
      x <- x[x$what %in% "fldfix", ]
    }
    
    
    if(can_reduce) stop("duplicated tag issue: can reduce ", st)
    
  } else {
   if(nrow(x) > 1) stop("duplicated tag issue: more than 2 rows in ", st)
    }
  
  
  # save changes (have to first delete the rows ad then rbind , since we may have reduced the number of rows)
  mort <- mort[!paste(mort$Tag, mort$StemTag) %in% st, ]
  mort <- rbind(mort, x)
}

# now, for those with conflict, randomly select one...
mort_dupST <- paste(mort$Tag, mort$StemTag)[duplicated(paste(mort$Tag, mort$StemTag))]
mort[paste(mort$Tag, mort$StemTag) %in% mort_dupST, ]

mort <- mort[!duplicated(paste(mort$Tag, mort$StemTag)), ]


# remove added columns
mort$what <- NULL
mort$"Data Correction" <- NULL



cat("data has been collated") # this is to troubleshoot CI on GitHub actions (see where errors happen)

## load the previous mortality surveys and make code history 
prev_mort <- read.csv(paste0("data/mortality_", regmatches(previous_status_column, regexpr("\\d{4}", previous_status_column)), ".csv"))

all_prev_mort <- lapply(list.files("data/", pattern = "\\d{4}.csv", full.names = T), read.csv)
StatusHistory <- cbind(all_prev_mort[[1]][, c("tag", "StemTag")], StatusHistory = apply(sapply(all_prev_mort, "[[", "current_year_status"), 1, paste, collapse = ";"))

StemEverDC <- paste(StatusHistory$tag, StatusHistory$StemTag)[grepl("DC", StatusHistory$StatusHistory)] # this is to identify trees that should not be flagged as missed during current census (see https://github.com/SCBI-ForestGEO/SCBImortality/issues/93)

# StemTwicePDLast <- paste(StatusHistory$tag, StatusHistory$StemTag)[grepl("PD;PD$", StatusHistory$StatusHistory)]  # this is to identify trees that were PD in the last 2 censuses (see https://github.com/SCBI-ForestGEO/SCBImortality/issues/93)
StemTwiceDead <- paste(StatusHistory$tag, StatusHistory$StemTag)[grepl("(PD|D|G|DC|DN|DS|NA);(PD|D|G|DC|DN|DS|NA)", StatusHistory$StatusHistory)] # this is to identify trees that were dead in the last 2 censuses (see https://github.com/SCBI-ForestGEO/SCBImortality/issues/93)

DownOrMissingLast <- paste(StatusHistory$tag, StatusHistory$StemTag)[grepl(";(DC|DN|NA)$", StatusHistory$StatusHistory)] 

# load and clean up the 3rd main census ####
main_census <-  read.csv(paste0("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.stem3.csv"))

cat("Main census data loaded") # this is to troubleshoot CI on GitHub actions (see where errors happen)


## convert dbh to numeric
main_census$dbh <- as.numeric(main_census$dbh)

## only keep trees > 10cm except for fraxinus and Chionanthus virginicus
main_census <-  main_census[grepl("^fr..|^ch..", main_census$sp) | (!is.na(main_census$dbh) & main_census$dbh >= 100), ]

## remove trees that are dead
# main_census <- main_census[!main_census$status %in% "D",]
main_census <- main_census[!grepl("DC|DN|DT", main_census$codes),] # see https://github.com/SCBI-ForestGEO/SCBImortality/issues/31#issuecomment-881702404


# load species table ####

spptable <- read.csv("https://raw.githubusercontent.com/SCBI-ForestGEO/SCBI-ForestGEO-Data/master/tree_main_census/data/census-csv-files/scbi.spptable.csv")

cat("spptable loaded") # this is to troubleshoot CI on GitHub actions (see where errors happen)


# fix empty lines in mort ####
idx_empty_line <- which(is.na(mort$Quad))
EAB_columns <- c("Crown thinning","Epicormic growth","EABF","D-shaped exit hole count","Crown position < 10 cm DBH")

# replace empty EAB column of line before by the EAB of empty lines

if(length(idx_empty_line) > 0) mort[idx_empty_line-1, EAB_columns] <- mort[idx_empty_line, EAB_columns] 

# remove empty lines
mort <- mort[!is.na(mort$Quad), ] # fix empty lines
mort <- mort[!is.na(mort$Species), ] # fix empty lines
mort <- mort[!is.na(mort$Tag), ] # fix empty lines

# remove repeated columns
mort <- mort[, unique(names(mort))]


cat("mort is ready") # this is to troubleshoot CI on GitHub actions (see where errors happen)


# give a % completion status ####
# percent_completion <- round(sum(paste(main_census$tag, main_census$StemTag) %in% paste(mort$Tag, mort$StemTag)) / nrow(main_census) * 100)
percent_completion <- round(sum(main_census$quadrat %in% as.numeric(mort$Quad))  / nrow(main_census) * 100)

png(file.path(here("testthat"), "reports/percent_completion.png"), width = 1, height = 1, units = "in", res = 150)
par(mar = c(0,0,0,0))
plot(0,0, axes = F, xlab = "", ylab = "", type = "n")
text(0,0, paste(percent_completion, "%"))
dev.off()
# write.table(percent_completion, file = file.path(here("testthat"), "reports/percent_completion.txt"),  col.names = F, row.names = F)

cat("% completion status done") # this is to troubleshoot CI on GitHub actions (see where errors happen)

# --- PERFORM CHECKS ---- ####

# prepare log files #####
require_field_fix_error_file <- NULL
will_auto_fix_error_file <- NULL
warning_file <- NULL
auto_fixes <- NULL # this will hold the list of errors and warnings for which we have decided of auto fixes

# for each quadrat censused, check all expected trees were censused ####
# filename <- file.path(here("testthat"), "reports/requires_field_fix/quadrat_censused_missing_stems.csv")
error_name = "missing_stem"


# idx_quadrat_censused <- main_census$quadrat %in% as.numeric(mort$Quad)


idx_errors <- !paste(main_census$tag, main_census$StemTag) %in% paste(mort$Tag, mort$StemTag) & main_census$quadrat %in% as.numeric(mort$Quad) &  # these are trees that are not in the quadrats censused so far
  !(paste(main_census$tag, main_census$StemTag) %in% StemEverDC | # this avoids flagging trees that were ever DC
  (paste(main_census$tag, main_census$StemTag) %in%  StemTwiceDead & paste(main_census$tag, main_census$StemTag) %in%  DownOrMissingLast)) #this avoids flagging trees stems that were dead 2 censuses in a row AND down or missing in the last census


idx_errors_warn <- idx_errors & (paste(main_census$tag, main_census$StemTag) %in%  paste(prev_mort$tag, prev_mort$StemTag)[prev_mort$current_year_status %in% "PD"] | main_census$sp %in% c( "fram", "frni", "frpe", "frsp", "chvi") & !is.na(main_census$dbh) & main_census$dbh <= 100) # only warn if tree was PD before or if is a fraxinus less than 10cm

idx_errors_err <- idx_errors & !(paste(main_census$tag, main_census$StemTag) %in%  paste(prev_mort$tag, prev_mort$StemTag)[prev_mort$current_year_status %in% "PD"] | main_census$sp %in% c( "fram", "frni", "frpe", "frsp", "chvi") & !is.na(main_census$dbh) & main_census$dbh <= 100)# error otherwise

if(sum(idx_errors_warn) > 0) {
  # write.csv(main_census[paste(main_census$tag, main_census$StemTag) %in% idx_errors, ], file = filename, row.names = F)
  data_to_add <- mort[1:sum(idx_errors_warn),]
  data_to_add[1:sum(idx_errors_warn), ] <- NA
  data_to_add[, c("Quad",
                  "Tag",
                  "StemTag",
                  "Species",
                  "QX",
                  "QY",
                  "DBH",
                  previous_status_column)] <-
    main_census[idx_errors_warn, c("quadrat", "tag", "StemTag", "sp", "gx", "gy", "dbh",  "status")]

  warning_file <- rbind(warning_file, data.frame(data_to_add, warning_name = error_name)) # switched to warning
  
  
  
} 

if(sum(idx_errors_err) > 0) {
  data_to_add <- mort[1:sum(idx_errors_err),]
  data_to_add[1:sum(idx_errors_err), ] <- NA
  data_to_add[, c("Quad",
                  "Tag",
                  "StemTag",
                  "Species",
                  "QX",
                  "QY",
                  "DBH",
                  previous_status_column)] <-
    main_census[idx_errors_err, c("quadrat", "tag", "StemTag", "sp", "gx", "gy", "dbh",  "status")]
  
  require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(data_to_add, error_name)) # switched to warning
  
  
  
} 
# else {
#   if(file.exists(filename) ) file.remove(filename)
# }


## IMPLEMENT CONSISTENT FIX FOR missing_stem ####
mort[idx_errors,]  # ignore # AUTO FIX
auto_fixes <- c(auto_fixes, "missing_stem")


# fixing/clarifying crown position fields #102
## DC
### set crown.position to NA for all
### if dead.crown.position was recorded as S and DBH > 200 mm, replace with NA
## DS
### if crown.position is blank - For all trees with dead.crown.position but not crown.position, fill in corresponding values using R script #106 --> dealt with later

idx_trees <- mort[, status_column] %in% "DC"
mort$`Crown position`[idx_trees] <- NA

idx_trees <- mort[, status_column] %in% "DC" & mort$`Dead crown position` %in% "S" & mort$DBH > 200
mort$`Dead crown position`[idx_trees] <- NA



# remove any tree with current status DN as we don't need to check errors on those ####
idx_trees <- !mort[, status_column] %in% c("DN")

mort <- mort[idx_trees, ]


# check if all species exist in species table, if not save a file, if yes, delete that file ####
error_name <- "species_code_error"

idx_error <- !mort$Species %in% spptable$sp

if(sum(idx_error) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_error,], error_name))





# for each quadrat censused, check that there is no duplicated stems ####
filename <- file.path(here("testthat"), "reports/will_auto_fix/quadrat_censused_duplicated_stems.csv")


idx_errors <- paste(mort$Tag, mort$StemTag)[duplicated(paste(mort$Tag, mort$StemTag))]


# if(length(idx_errors) > 0) {
  write.csv(mort[paste(mort$Tag, mort$StemTag) %in% idx_errors, ], file = filename, row.names = F)
# } else {
#   if(file.exists(filename) ) file.remove(filename)
# }






# check that all censused trees have a crown position recorded ####
error_name <- "missing_crown_position"

idx_trees <- mort[, status_column] %in% c("A", "AU", "DS")

idx_errors <- is.na(mort$'Crown position') & is.na(mort$'Dead crown position') & idx_trees ### add "& is.na(mort$'Dead crown position')" to address this issue: https://github.com/SCBI-ForestGEO/SCBImortality/issues/103

if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


### add this bit to address this issue: https://github.com/SCBI-ForestGEO/SCBImortality/issues/103
error_name <- "missing_crown_position_while_dead_crown_position_is_recorded"

idx_trees <- mort[, status_column] %in% c("A", "AU", "DS")

idx_errors <- is.na(mort$'Crown position')  & !is.na(mort$'Dead crown position') & idx_trees

if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name = error_name)) 


## IMPLEMENT CONSISTENT FIX FOR missing_crown_position_while_dead_crown_position_is_recorded ####
mort[idx_errors,'Crown position'] <- c("S" = 1,
  "I" = 2,
  "C" = 3,
  "CD" = 3,
  "D" = 4,
  "OG"= 5)[mort[idx_errors,'Dead crown position']]  # see issue #106 # AUTO FIX
auto_fixes <- c(auto_fixes, "missing_crown_position_while_dead_crown_position_is_recorded")


# check that all censused trees have a percent of crown intact recorded ####
error_name <- "missing_percent_crown_intact"


idx_trees <- mort[, status_column] %in% c("A", "AU", "DS")

idx_errors <- is.na(mort$'Percentage of crown intact') & idx_trees


if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


# check that all censused trees have a percent of crown living recorded ####
error_name <- "missing_percent_crown_living"


idx_trees <- mort[, status_column] %in% c("A", "AU")

idx_errors <- is.na(mort$'Percentage of crown living') & idx_trees


if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ] , error_name))


idx_trees <- mort[, status_column] %in% c("DS") # for DS trees: change to auto-fix error, will have to fill with "0".

idx_errors <- is.na(mort$'Percentage of crown living') & idx_trees

if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ] , error_name))


## IMPLEMENT CONSISTENT FIX FOR missing_percent_crown_living ####
mort[idx_errors,'Percentage of crown living'] <- 0 # For DS trees, fill with 0 # AUTO FIX
auto_fixes <- c(auto_fixes, "missing_percent_crown_living")



# check percent of crown living <=  percent of crown intact####
error_name <- "crown_living_greater_than_crown_intact"




idx_trees <- mort[, status_column] %in% c("A", "AU", "DS")

idx_errors <- !is.na(mort$'Percentage of crown living') & !is.na(mort$'Percentage of crown intact') & mort$'Percentage of crown living' > mort$'Percentage of crown intact' & idx_trees


if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ] , error_name))


# check percent newly censused trees (DS or DC)	have percentage of crown living = 0####
error_name <- "dead_but_crown_living_not_zero"




idx_trees <- mort[, status_column] %in% c("DS", "DC")

idx_errors <- !is.na(mort$'Percentage of crown living') & mort$'Percentage of crown living'> 0 &  idx_trees


if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ] , error_name))


# check that newly censused alive trees have no FAD selected; no record of wounded main stem, canker, or rotting trunk; DWR (dead with resprouts) not selected ####
error_name <- "status_A_but_unhealthy"



idx_trees <- mort[, status_column] %in% "A"
idx_FAD <- !is.na(mort$FAD)
idx_wound <- !is.na(mort$'Wounded main stem')
idx_canker <- !is.na(mort$'Canker; swelling, deformity')
idx_rot <- !is.na(mort$'Rotting trunk')
idx_DWR <- !is.na(mort$'DWR') & !mort$'DWR' %in% "False"


idx_errors <- idx_trees & (idx_FAD | idx_wound | idx_wound | idx_canker | idx_rot | idx_DWR)


if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))



## and vice-versa ####
# error_name <- "unhealthy_but_wrong_status"
# 
# 
# 
# idx_trees <- mort[, status_column] %in% c("AU", "DC", "DS")
# idx_FAD <- !is.na(mort$FAD)
# idx_wound <- !is.na(mort$'Wounded main stem')
# idx_canker <- !is.na(mort$'Canker; swelling, deformity')
# idx_rot <- !is.na(mort$'Rotting trunk')
# idx_DWR <- !is.na(mort$'DWR') & !mort$'DWR' %in% "False"
# 
# 
# idx_errors <- !idx_trees & (idx_FAD | idx_wound | idx_wound | idx_canker | idx_rot | idx_DWR)
# 
# if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))
# 





# check that status 'AU' does not have 	DWR (dead with resprouts)  selected ####
error_name <- "status_AU_but_DWR_selected"



idx_trees <- mort[, status_column] %in% "AU"
idx_DWR <- !is.na(mort$'DWR') & !mort$'DWR' %in% "False"


idx_errors <- idx_trees & idx_DWR

if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


# check that status 'DS' or 'DC' have a dbh measured  ####
error_name <- "status_DS_or_DC_but_DBH_not_measured"

idx_trees <- mort[, status_column] %in% c("DS", "DC")
idx_previously_dead <- !mort[,previous_status_column] %in% c("AU","A") & !is.na(mort[,previous_status_column])
idx_no_DBH_if_dead <- is.na(mort$'Dead DBH')


idx_errors <- idx_trees & idx_no_DBH_if_dead & !idx_previously_dead


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))

## IMPLEMENT CONSISTENT FIX FOR status_DS_or_DC_but_DBH_not_measured ####
mort[idx_errors,'Dead DBH'] # Leave as NA # AUTO FIX
auto_fixes <- c(auto_fixes, "status_DS_or_DC_but_DBH_not_measured")



# check that status 'DS' or 'DC' have a dbh within 2cm of most recent census DBH  ####
error_name <- "DBH_dead_suspicious"

idx_trees <- mort[, status_column] %in% c("DS", "DC")
idx_previously_dead <- grepl("D", mort[,previous_status_column]) & !is.na(mort[,previous_status_column])

idx_DBH_ouside_range <- !is.na(mort$'Dead DBH') & !is.na(as.numeric(mort$DBH)) & (abs(mort$'Dead DBH' - as.numeric(mort$DBH)) > 50)

idx_errors <- idx_trees & !idx_previously_dead & idx_DBH_ouside_range

if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))



idx_errors <- idx_trees & idx_previously_dead & idx_DBH_ouside_range # need to fill dbh measurements with NA

if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## IMPLEMENT CONSISTENT FIX FOR DBH_dead_suspicious ####
mort[idx_errors, 'Dead DBH'] <- NA # replace measurements with NA # AUTO FIX
auto_fixes <- c(auto_fixes, "DBH_dead_suspicious")


# check that newly censused 'AU', 'DS' or 'DC trees that were alive in previous census have at least one FAD is selected (OR level selected for `wounded main stem`,`canker,swelling,deformity`, `rotting main stem`) ####
error_name <- "status_AU_DS_or_DC_but_no_FAD"

idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_previously_dead <- idx_previously_dead <- grepl("D", mort[,previous_status_column]) & !is.na(mort[,previous_status_column])

idx_no_FAD <- is.na(mort$FAD)

idx_wound <- is.na(mort$'Wounded main stem')
idx_canker <- is.na(mort$'Canker; swelling, deformity')
idx_rot <- is.na(mort$'Rotting trunk')

# idx_living_crown <- mort$"Percentage of crown living" == 100 # this was for OR **status is AU and `percentage of crown living`<100**  



idx_errors <- idx_trees & (idx_no_FAD & idx_wound & idx_canker & idx_rot)  & !idx_previously_dead

# idx_errors[mort[, status_column] %in% "AU" & !idx_living_crown] <- FALSE # overwrite to FALSE for trees that are AU and crown not intact


if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name)) # this was for OR **status is AU and `percentage of crown living`<100**  


# check that newly censused 'AU', 'DS' or 'DC trees have at one photo taken ####
# filename <- file.path(here("testthat"), "reports/status_AU_DS_or_DC_but_no_photo.csv") # edit file name here
# 
# 
# 
# idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
# idx_no_FAD <- is.na(mort$FAD)
# 
# idx_errors <- idx_trees & idx_no_FAD
# 
# 
# if(sum(idx_errors) > 0) {
#   write.csv(mort[idx_errors, ], file = filename, row.names = F)
# } else {
#   if(file.exists(filename) ) file.remove(filename)
# }
# 
# 

# check that newly censused 'AU', 'DS' or 'DC with "wound" selected as FAD have selected a level for wounded main stem ####
error_name <- "wounded_but_no_level"

idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_wounded <- !is.na(mort$FAD) & grepl("W", mort$FAD)
idx_wnd_main_stem <- !is.na(mort$'Wounded main stem')


idx_errors <- idx_trees & idx_wounded & !idx_wnd_main_stem

if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))
# require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## IMPLEMENT CONSISTENT FIX FOR wounded_but_no_level ####
mort[idx_errors,] # ignore (leave wound level as NA)  # AUTO FIX
auto_fixes <- c(auto_fixes, "wounded_but_no_level")

## and vice versa ####
error_name <- "wounded_level_but_wrong_status_or_FAD"

idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_wounded <- !is.na(mort$FAD) & grepl("W", mort$FAD)
idx_wnd_main_stem <- !is.na(mort$'Wounded main stem')

idx_errors <- !idx_trees & !idx_wounded & idx_wnd_main_stem

if(sum(idx_errors) > 0) {
  idx_errors <- (!idx_trees | !idx_wounded) & idx_wnd_main_stem


will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))
}

## IMPLEMENT CONSISTENT FIX FOR wounded_level_but_wrong_status_or_FAD ####
mort[idx_errors, "FAD"] <- gsub("W,W", "W", ifelse(mort[idx_errors, "FAD"] == "none" | is.na(mort[idx_errors, "FAD"]), "W", paste0(mort[idx_errors, "FAD"], ",W"))) # add W to FAD and make status AU # AUTO FIX
mort[idx_errors, status_column] <- "AU" # add W to FAD and make status AU # AUTO FIX
auto_fixes <- c(auto_fixes, "wounded_level_but_wrong_status_or_FAD")

# check that newly censused 'AU', 'DS' or 'DC with "canker" selected as FAD have selected a level for canker,swelling,deformity ####
error_name <- "canker_but_no_level"



idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_canker <- !is.na(mort$FAD) & grepl("K", mort$FAD)
idx_ckr_level <- !is.na(mort$'Canker; swelling, deformity')


idx_errors <- idx_trees & idx_canker & !idx_ckr_level


if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))
 # require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))

## IMPLEMENT CONSISTENT FIX FOR canker_but_no_level ####
mort[idx_errors,] # ignore (leave canker level as NA)  # AUTO FIX
auto_fixes <- c(auto_fixes, "canker_but_no_level")




## and vice versa ####
error_name <- "canker_level_but_wrong_status_or_FAD"



idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_canker <- !is.na(mort$FAD) & grepl("K", mort$FAD)
idx_ckr_level <- !is.na(mort$'Canker; swelling, deformity')


idx_errors <- (!idx_trees & !idx_canker) & idx_ckr_level


if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))

## IMPLEMENT CONSISTENT FIX FOR canker_level_but_wrong_status_or_FAD ####
mort[idx_errors, "FAD"] <- gsub("K,K", "K", ifelse(mort[idx_errors, "FAD"] == "none" | is.na(mort[idx_errors, "FAD"]), "K", paste0(mort[idx_errors, "FAD"], ",K"))) # add K to FAD and make status AU # AUTO FIX
mort[idx_errors, status_column] <- "AU" # add K to FAD and make status AU # AUTO FIX
auto_fixes <- c(auto_fixes, "canker_level_but_wrong_status_or_FAD")


# check that newly censused 'AU', 'DS' or 'DC with "rotting stem" selected as FAD have selected a level for rotting main stem ####
error_name <- "rot_but_no_level"

idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_rot <- !is.na(mort$FAD) & grepl("\\<R\\>", mort$FAD)
idx_rot_level <- !is.na(mort$'Rotting trunk')


idx_errors <- idx_trees & idx_rot & !idx_rot_level


if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))
# require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))

## IMPLEMENT CONSISTENT FIX FOR rot_but_no_level ####
mort[idx_errors,] # ignore (leave rot level as NA)  # AUTO FIX
auto_fixes <- c(auto_fixes, "rot_but_no_level")

## and vice versa ####
error_name <- "rot_level_but_wrong_status_or_FAD"



idx_trees <- mort[, status_column] %in% c("AU","DS", "DC")
idx_rot <- !is.na(mort$FAD) & grepl("R\\>", mort$FAD)
idx_rot_level <- !is.na(mort$'Rotting trunk')


idx_errors <- (!idx_trees & !idx_rot) & idx_rot_level


if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))



# check that there is D.shaped.exit.hole.count when EABF is DE ####
error_name <- "DE_but_no_exit_hole_count"

idx_DE <- !is.na(mort$EABF) & grepl("DE", mort$EABF)
idx_exit_count <- !is.na(mort$"D-shaped exit hole count") & mort$"D-shaped exit hole count">0


idx_errors <- idx_DE & !idx_exit_count

if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) #if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## and vice versa ####
error_name <- "exit_hole_count_no_DE_EABF"

idx_errors <- !idx_DE & idx_exit_count

if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## IMPLEMENT CONSISTENT FIX FOR exit_hole_count_no_DE_EABF ####
mort[idx_errors, "EABF"] <- ifelse(mort[idx_errors, "EABF"] == "none" | is.na(mort[idx_errors, "EABF"], "DE", paste0(mort[idx_errors, "EABF"], ",DE"))) # add DE to EABF # AUTO FIX
auto_fixes <- c(auto_fixes, "exit_hole_count_no_DE_EABF")

# check that newly censused 'A' or 'AU', were A or AU in previous year ####
warning_name <- "Dead_but_now_alive"

idx_trees <- mort[, status_column] %in% c("AU","A")
idx_previously_dead <- !mort[,previous_status_column] %in% c("AU","A") & !is.na(mort[,previous_status_column])


idx_errors <- idx_trees & idx_previously_dead


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name)) 

## IMPLEMENT CONSISTENT FIX FOR Dead_but_now_alive ####
mort[idx_errors, ] # Leave as is and we will deal with when creating allmort # AUTO FIX
auto_fixes <- c(auto_fixes, "Dead_but_now_alive")


# check that newly censused 'A' or 'AU' or 'DS', were not 'DC' in previous year ####
warning_name <- "DC_but_now_DS"

idx_trees <- mort[, status_column] %in% c("DS")
idx_previously_dead <- mort[,previous_status_column] %in% c("DC") & !is.na(mort[,previous_status_column])


idx_errors <- idx_trees & idx_previously_dead


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name)) 

# check that newly  censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI), have Crown thinning, Epicormic growth, Crown position < 10 cm DBH (for stems <10cm) all recorded ####
error_name <- "missing_EAB_info"


idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_missing_EAB_info <- !complete.cases(mort[, c("Crown thinning", "Epicormic growth") ])
idx_missing_crwn_pos <- !complete.cases(mort[, c("Crown position < 10 cm DBH")])
idx_trees_less_10cm <-  !is.na( as.numeric(mort$DBH)) & as.numeric(mort$DBH) <100
     

idx_status <- !mort[, status_column] %in% c("DN")
idx_previously_dead <- idx_previously_dead <- grepl("D", mort[,previous_status_column]) & !is.na(mort[,previous_status_column])


idx_errors <- ((idx_trees & idx_missing_EAB_info) |  (idx_trees & idx_missing_crwn_pos & idx_trees_less_10cm)) & (idx_status& !idx_previously_dead)


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # downgraded from error to warning


## IMPLEMENT CONSISTENT FIX FOR missing_EAB_info ####
mort[idx_errors,] # leave as is # AUTO FIX
auto_fixes <- c(auto_fixes, "missing_EAB_info")


# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if Epicormic growth>0, tree is AU ####
error_name <- "epicormic_growth_but_not_AU"


idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_epicormic <- !is.na(mort$`Epicormic growth`) & mort$'Epicormic growth' > 0
idx_status <- mort[, status_column] %in% c("AU")



idx_errors <- idx_trees & idx_epicormic & !idx_status



if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) will_auto_fix_error_file <- rbind(will_auto_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## IMPLEMENT CONSISTENT FIX FOR epicormic_growth_but_not_AU ####
mort[idx_errors, status_column] <- "AU" # change status to AU # AUTO FIX
auto_fixes <- c(auto_fixes, "epicormic_growth_but_not_AU")



# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if Crown thinning>1, tree is AU or dead ####
error_name <- "crown_thinning_more_than_1_but_not_AU_or_dead"


idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_crown <- !is.na(mort$'Crown thinning') & mort$'Crown thinning' > 1
idx_status <- mort[, status_column] %in% c("A")



idx_errors <- idx_trees & idx_crown & idx_status

if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


## IMPLEMENT CONSISTENT FIX FOR crown_thinning_more_than_1_but_not_AU_or_dead ####
mort[idx_errors, status_column] <- "AU" # change status to AU # AUTO FIX
auto_fixes <- c(auto_fixes, "crown_thinning_more_than_1_but_not_AU_or_dead")

# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if any EABF recorded, tree is AU or dead ####
error_name <- "EABF_recorded_but_not_AU_or_dead"

idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_EABF <- !is.na(mort$EABF) & !mort$EABF %in% "none"
idx_status <- mort[, status_column] %in% c("A")



idx_errors <- idx_trees & idx_EABF & idx_status


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))

## IMPLEMENT CONSISTENT FIX FOR EABF_recorded_but_not_AU_or_dead ####
mort[idx_errors, status_column] <- "AU" # change status to AU # AUTO FIX
auto_fixes <- c(auto_fixes, "EABF_recorded_but_not_AU_or_dead")

# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if D-shaped exit hole count>0, tree is AU or dead ####
error_name <- "exit_hole_count_but_not_AU_or_dead"




idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_exit_hole <- mort$'D-shaped exit hole count' > 0 & !is.na(mort$'D-shaped exit hole count')
idx_status <- mort[, status_column] %in% c("A")



idx_errors <- idx_trees & idx_exit_hole & idx_status


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) #  if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))



# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if tree is dead, Epicormic growth=0 ####
error_name <- "dead_but_epicormic_more_than_0"

idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_epicormic <- !is.na(mort$'Epicormic growth') & mort$'Epicormic growth' > 0
idx_status <- !mort[, status_column] %in% c("A", "AU")
idx_previously_dead <- idx_previously_dead <- grepl("D", mort[,previous_status_column]) & !is.na(mort[,previous_status_column])


idx_errors <- idx_trees & idx_epicormic & (idx_status & !idx_previously_dead)



if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))


# check that, for newly censused trees (FRAM, FRNI, FRPE, FRSP, or CHVI),	if tree is dead, Crown thinning=5 ####
error_name <- "dead_but_crown_thinning_less_than_5"


idx_trees <- mort$Species %in% c( "fram", "frni", "frpe", "frsp", "chvi")
idx_crown <- !is.na(mort$'Crown thinning') & mort$'Crown thinning' <5
idx_status <- !mort[, status_column] %in% c("A", "AU")
idx_previously_dead <- grepl("D", mort[,previous_status_column]) & !is.na(mort[,previous_status_column])



idx_errors <- idx_trees & idx_crown & (idx_status & !idx_previously_dead)


if(sum(idx_errors) > 0) warning_file <- rbind(warning_file, data.frame(mort[idx_errors, ], warning_name = error_name)) # if(sum(idx_errors) > 0) require_field_fix_error_file <- rbind(require_field_fix_error_file, data.frame(mort[idx_errors, ], error_name))



# clean and save files ####

## remove empty tags
require_field_fix_error_file <- require_field_fix_error_file[!is.na(require_field_fix_error_file$Tag),]

will_auto_fix_error_file <- will_auto_fix_error_file[!is.na(will_auto_fix_error_file$Tag),]

warning_file <- warning_file[!is.na(warning_file$Tag),]

## order by quadrat and tag
if(!is.null(require_field_fix_error_file)) {
  require_field_fix_error_file <- require_field_fix_error_file[order(as.numeric(require_field_fix_error_file$Quad), require_field_fix_error_file$Tag, require_field_fix_error_file$StemTag),]
}

if(!is.null(will_auto_fix_error_file)) {
  will_auto_fix_error_file <- will_auto_fix_error_file[order(will_auto_fix_error_file$Quad, will_auto_fix_error_file$Tag, will_auto_fix_error_file$StemTag),]
}


if(!is.null(warning_file)) warning_file <- warning_file[order(warning_file$Quad, warning_file$Tag, warning_file$StemTag),]


cat("reports prepared") # this is to troubleshoot CI on GitHub actions (see where errors happen)


# if errors/warnings exist save, else delete


if(!is.null(require_field_fix_error_file)) {
  if(nrow(require_field_fix_error_file)>0) {
    
    write.csv(
      require_field_fix_error_file[, c(ncol(require_field_fix_error_file), 1:(ncol(require_field_fix_error_file) -1))], 
      file = file.path(here("testthat"), "reports/requires_field_fix/require_field_fix_error_file.csv"), 
      row.names = F
    )
    
    cat("require_field_fix_error_file was saved") # this is to troubleshoot CI on GitHub actions (see where errors happen)
    
    

    # also make quad a factor so other things work
    require_field_fix_error_file$Quad <- factor(require_field_fix_error_file$Quad,  levels = sort(unique(mort$Quad)))
  }  
} else {
  if(file.exists(file.path(here("testthat"), "reports/requires_field_fix/require_field_fix_error_file.csv"))) file.remove(file.path(here("testthat"), "reports/requires_field_fix/require_field_fix_error_file.csv"))
}
  
csv_mort_filename <-  paste0("raw_data/Mortality_Survey_", regmatches(latest_FFFs, regexpr("\\d{4}", latest_FFFs)), ".csv")# gsub("xlsx", "csv", gsub("FFF_excel/", "", latest_FFFs))


# if all errors and warning have been dealt with or we are okay to ignore:
if(all(c(will_auto_fix_error_file$error_name, warning_file$warning_name) %in% auto_fixes)) {
     write.csv(mort, file  = csv_mort_filename, row.names = F)
  cat("csv_mort_filename was saved") # this is to troubleshoot CI on GitHub actions (see where errors happen)
  } else {
    # if  error, delete any existing CSV mort file
    if(file.exists(csv_mort_filename)) file.remove(csv_mort_filename)
    
    warning(paste("-", setdiff(c(will_auto_fix_error_file$error_name, warning_file$warning_name), auto_fixes), collapse = "\n"), "\nstill needs to be dealt with the auto-fix")
  }
  # if no errors, and all things are dealt with with auto fix --> save the current mort file as CSV



if(!is.null(will_auto_fix_error_file) ) {
  if(nrow(will_auto_fix_error_file) > 0) {
    write.csv(
      will_auto_fix_error_file[, c(ncol(will_auto_fix_error_file), 1:(ncol(will_auto_fix_error_file) -1))], 
      file = file.path(here("testthat"), "reports/will_auto_fix/will_auto_fix_error_file.csv"), 
      row.names = F
    )
    cat("will_auto_fix_error_file was saved") # this is to troubleshoot CI on GitHub actions (see where errors happen)
    
    # also make quad a factor so other things work
    will_auto_fix_error_file$Quad <- factor(will_auto_fix_error_file$Quad,  levels = sort(unique(mort$Quad)))
  }
} else {
  if(file.exists(file.path(here("testthat"), "reports/will_auto_fix/will_auto_fix_error_file.csv"))) file.remove(file.path(here("testthat"), "reports/will_auto_fix/will_auto_fix_error_file.csv"))
}


if(!is.null(warning_file)) {
   if (nrow(warning_file)>0) {
  write.csv(
    warning_file[, c(ncol(warning_file), 1:(ncol(warning_file) -1))], 
    file = file.path(here("testthat"), "reports/warnings/warnings_file.csv"), 
    row.names = F
  )
  
     cat("warning_file was saved") # this is to troubleshoot CI on GitHub actions (see where errors happen)
     
     # also make quad a factor so other things work
     warning_file$Quad <- factor(warning_file$Quad,  levels = sort(unique(mort$Quad)))
} else {
  if(file.exists(file.path(here("testthat"), "reports/warnings/warnings_file.csv"))) file.remove(file.path(here("testthat"), "reports/warnings/warnings_file.csv"))
  
}
}


# KEEP TRACK OF ALL THE ISSUES ####

all_reports <- list.files(here("testthat/reports/", c("requires_field_fix", "will_auto_fix", "warnings")), recursive = T, pattern = ".csv", full.names = T)


for(f in all_reports) {
  
  new_f <- gsub("/reports/", "/reports/trace_of_reports/", f)
  new_f <- gsub("/requires_field_fix/|/will_auto_fix/|/warnings/", "",new_f)
  
  if(file.exists(new_f)) write.csv(unique(rbind(read.csv(new_f), read.csv(f)[names(read.csv(new_f))])), file = new_f, row.names = F)
  else write.csv(read.csv(f), file = new_f, row.names = F)
  
}

# generate a file with summary for each quadrat ####
# quadrat_censused_missing_stems <- read.csv(file.path(here("testthat"), "reports/requires_field_fix/quadrat_censused_missing_stems.csv"))
quadrat_censused_duplicated_stems <- read.csv(file.path(here("testthat"), "reports/will_auto_fix/quadrat_censused_duplicated_stems.csv"))

quad_with_any_issue <- sort(unique(c(as.character(require_field_fix_error_file$Quad), 
                                     as.character(will_auto_fix_error_file$Quad), 
                                     as.character(warning_file$Quad), 
                                     as.character(quadrat_censused_duplicated_stems$quadrat))))

quad_summary <- data.frame(Quad = quad_with_any_issue, 
                           n_tag_error_field_fix = c(table(require_field_fix_error_file$Quad[!require_field_fix_error_file$error_name %in% "missing_stem"]))[as.character(quad_with_any_issue)], 
                           n_tag_error_auto_fix = c(table(will_auto_fix_error_file$Quad))[as.character(quad_with_any_issue)],
                           n_tag_warnings = c(table(warning_file$Quad))[as.character(quad_with_any_issue)],
                           n_missing_tags = c(table(require_field_fix_error_file$Quad[require_field_fix_error_file$error_name %in% "missing_stem"]))[as.character(quad_with_any_issue)],
                           n_duplicated_tags = c(table(quadrat_censused_duplicated_stems$Quad))[as.character(quad_with_any_issue)])

quad_summary$sum_missing_and_errors <- quad_summary$n_missing_tags + quad_summary$n_tag_error_field_fix

write.csv(quad_summary[order(as.numeric(quad_summary$Quad)), ], file.path(here("testthat"), "reports/quadrat_n_errors_summary.csv"), row.names = F)




# create list of tag numbers that need replacement see https://github.com/SCBI-ForestGEO/2023census/issues/7

# get all the lines with a value in Tag maintenance
# x <- mort[!is.na(mort$`Tag maintenance`),]
x <- mort[mort$`Tag maintenance` %in% "RT",]

cat(paste(x$Tag, collapse = ","), file = paste0(dirname(getwd()), "/2023census/tags/list_tags_needing_new_tags.txt"), quote = F)


write.csv(x[, c("Tag", "StemTag", "Quad", "Species", "QX", "QY", "DBH", "Status 2022", "Tag maintenance")], file = paste0(dirname(getwd()), "/2023census/tags/list_tags_needing_new_tags.csv"), row.names = F)



x <- mort[mort$`Tag maintenance` %in% "NN",]
dim(x)
dput(x$Tag)

cat(paste(x$Tag, collapse = ","), file=paste0(dirname(getwd()), "/2023census/tags/list_tags_needing_nails.txt"),  quote = F)

write.csv(x[, c("Tag", "StemTag", "Quad", "Species", "QX", "QY", "DBH", "Status 2022", "Tag maintenance")], file = paste0(dirname(getwd()), "/2023census/tags/list_tags_needing_nails.csv"), row.names = F)

